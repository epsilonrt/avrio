/**
@file main_page.dox
@brief Page de garde de la documentation
@author epsilonRT. Copyright © 2011-2016 All rights reserved.

@mainpage Présentation
@htmlonly
<p>Copyright 2010-2016 (c), epsilonRT</p>

<p><a href="http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html">
  <img src="https://raw.githubusercontent.com/epsilonrt/gxPL/master/doc/images/osi.png" alt="osi.png" align="right" valign="top">
</a></p>

<p>AvrIO est un projet Open Source sous
<a href="http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html">CeCILL Free Software License Version 2.1</a>
dont l'objectif est d'offrir une bibliothèque C pour les microcontrôleurs AVR
d'Atmel.<br>
AvrIO est développé en C et en assembleur.<br>
Il utilise la chaîne de développement GNU GCC disponible sur 
la plupart des plateformes : Windows, Linux et autres Unix like, MacOS...</p>

<p><strong>Pourquoi AvrIO ?</strong></p>

<p>Lorsque l'on souhaite developper un projet utilisant un microcontrôleur, on se
heurte rapidement à la problématique de choisir un système de prototypage.
Il existe un grand nombre de cartes prototypes dont la plus connue dans le monde
ATMEL est sans nul doute ARDUINO.</p>

<p>Certes cette solution est séduisante car elle
fournit une solution "Tout-en-Un" à l'amateur soucieux d'arriver rapidement à 
une solution en DIY.</p>

<p>Le problème se complique lorsqu'on souhaite passer son projet à une étape 
un peu plus professionnelle, voir industrielle en developpant une carte spécifique.</p>

<p>On a alors 2 choix possibles:</p>

<ol>
<li>respecter l'architecture matérielle d'une carte ARDUINO et utiliser la 
librairie ARDUINO, ce qui est loin d'être souple, ou</li>
<li>modifier la librairie ARDUINO pour l'adapter à la nouvelle carte, ce qui est
loin d'être simple (car la librairie ARDUINO n'est pas prévue pour cela).</li>
</ol>

<p>Si on ajoute à cela:</p>

<ol>
<li>un fort couplage entre l'<a href="https://fr.wikipedia.org/wiki/Environnement_de_d%C3%A9veloppement">IDE</a> 
ARDUINO et sa librairie (on est plus ou moins obliger d'utiliser l'IDE prévue...)</li>
<li>L'absence de prise en compte de l'utilisation d'un 
<a href="https://fr.wikipedia.org/wiki/D%C3%A9bogueur">débogueur</a> comme 
<a href="http://www.atmel.com/tools/AVRDRAGON.aspx">AVR Dragon</a> ou
<a href="http://www.atmel.com/tools/JTAGICE3.aspx">JTAG ICE</a>,</li>
</ol>

<p>cela fait beaucoup dans un contexte professionnel...</p>

<p>AvrIO fournit une solution élégante permettant de gommer les différences entre
le code mis au point lors de la phase de prototypage sur une carte du type 
d'ARDUINO (DVK, USBKEY, STK ...) et la phase de production sur la carte finale.
Il reprend en cela les avantages de la 
<a href="https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_objet">conception orienté "Objet"</a></p>

<p>En clair, aucune ligne de code de l'application mise au point lors du prototypage
n'est modifiée pour la solution finale.</p>

<p>Cela est rendu possible en effectuant une séparation stricte entre le code et
la description matérielle. Cette description est réaliséé grâce à des fichiers
d'entête dans le dossier <strong>board</strong>. Le développeur aura donc uniquement à créer
un nouveau dossier <strong>board</strong> pour sa nouvelle carte en utilisant comme modèles 
les nombreux exemples du dossier 
<a href="https://github.com/epsilonrt/avrio/tree/master/board">board</a> d'AvrIO.</p>

<p>AvrIO n'est pas lié à un IDE spécifique, on peut l'utiliser en ligne de 
commande (<strong>make</strong>, <strong>make program</strong>, <strong>make debug</strong> ...), avec 
<a href="https://www.geany.org/">Geany</a>, 
<a href="http://www.atmel.com/tools/studioarchive.aspx">AvrStudio 4</a>, 
<a href="http://www.codelite.org/">CodeLite</a>, <a href="https://eclipse.org/">Eclipse</a>... </p>

<p>Il suffit que l'IDE en question ai prévu l'intégration de projet utilisant un 
Makefile.</p>

<p>Pour ma part, j'ai une préférence pour <a href="http://www.codelite.org/">CodeLite</a>, 
qui est solution multiplateforme et puissante. <a href="http://www.codelite.org/">CodeLite</a>
me permet sous Linux un débogage via <a href="https://www.gnu.org/software/gdb/">GDB</a> 
avec des fonctionnalités très proches d'AVR Studio 4 sous Windows... Mais il 
ne s'agit là que d'un avis personnel.</p>

<p>AvrIO est développé :</p>

<ul>
<li>de façon modulaire, c'est à dire, qu'il est découpé en modules. 
Chaque module peut être validé ou non, <strong>configuré et adapté facilement</strong> 
grâce à des fichiers séparés du code source. Les dépendances entre modules 
sont limitées au stricte nécessaire.</li>
<li>de façon à réduire l'occupation mémoire que ce soit RAM ou FLASH permettant 
son utilisation sur les modèles les plus économiques de la famille AVR (tiny).</li>
<li>de façon à intégrer d'autres projets Open Source comme par exemple 
<a href="http://freemodbus.berlios.de/">freemodbus</a>, 
<a href="https://github.com/arduino/Arduino">Arduino</a> ou 
<a href="http://www.epsilonrt.com/avrio/group__avrx__module.html">AvrX</a> 
sans modification de leur licence.</li>
</ul>

<p>AvrIO complète la bibliothèque C standard 
<a href="http://www.nongnu.org/avr-libc/">avr-libc</a> dans plusieurs domaines:</p>

<ul>
<li>Les entrées-sorties:
<ul>
<li>les broches <a href="http://www.epsilonrt.com/avrio/group__dpin__module.html">numériques</a> et 
<a href="http://www.epsilonrt.com/avrio/group__adc__module.html">analogiques</a>,</li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__led__module.html">leds</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__ledrgb__module.html">leds RGB</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__button__module.html">boutons poussoirs</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__switch__module.html">micro-switchs</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__bisrelay__module.html">relais bistable</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__lcd__module.html">afficheurs LCD</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__keyb__module.html">claviers</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__counter__module.html">compteurs</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__irq__module.html">interruptions</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__rtc__module.html">RTC</a>,</li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__mmc__module.html">cartes mémoires SD</a>...</li>
</ul></li>
<li>Les capteurs analogiques:
<ul>
<li><a href="http://www.epsilonrt.com/avrio/group__adc__sensor__module.html">linéaires et non linéaires</a></li>
<li><a href="http://www.epsilonrt.com/avrio/group__ntc__module.html">CTN</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__mq135__module.html">MQ135</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__temt__module.html">TEMT6000</a>, </li>
</ul></li>
<li>Les capteurs numériques: 
<ul>
<li><a href="http://www.epsilonrt.com/avrio/group__hih6130__module.html">HIH6130</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__hsc__module.html">HSC</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__ds1621__module.html">DS1621</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__tsl230__module.html">TSL230</a> ...</li>
</ul></li>
<li>Les bus <a href="http://www.epsilonrt.com/avrio/group__twi__group.html">I2C</a> 
et <a href="http://www.epsilonrt.com/avrio/group__spi__module.html">SPI</a></li>
<li>Les réseaux: 
<ul>
<li>Liaisons série
<a href="http://www.epsilonrt.com/avrio/group__serial__module.html">matérielles</a> avec
gestion du RS485 et <a href="file:///home/pascal/src/avrio/doc/html/group__serial__sw__module.html">logicielles</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__avrio__xbee.html">XBee</a> série 1 (IEEE802.15.4) et série 2 (Zigbee), </li>
<li><a href="http://www.epsilonrt.com/avrio/group__ax25__module.html">Ax25</a>, </li>
<li><a href="http://www.epsilonrt.com/avrio/group__afsk__module.html">AFSK</a> ...</li>
</ul></li>
<li>La robotique: <br />
<ul>
<li>la commande PWM des <a href="http://www.epsilonrt.com/avrio/group__bdcm__module.html">moteurs DC</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__servo__module.html">servo-moteurs RC</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__encoder__module.html">encodeurs incrémentaux</a>,  </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__acc3d__module.html">accéléromètres</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__comp3d__module.html">compas magnétiques</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__gyro3d__module.html">gyroscopes</a>, </li>
<li>les <a href="http://www.epsilonrt.com/avrio/group__imu__module.html">centrales intertielles</a> ...</li>
</ul></li>
<li>Le traitement du signal avec 
<ul>
<li>les filtres d'asservissement <a href="http://www.epsilonrt.com/avrio/group__pid__module.html">PID</a>, </li>
<li>les filtres de <a href="http://www.epsilonrt.com/avrio/group__kalman__module.html">Kalman</a>,</li>
<li>l'algorithme <a href="http://www.epsilonrt.com/avrio/group__dcm__module.html">DCM</a> "Direction Cosine Matrix" ...</li>
</ul></li>
<li>Le multitâche en fournissant par exemple un 
<a href="http://www.epsilonrt.com/avrio/group__task__module.html">ordonnanceur collaboratif</a>, 
des dispositifs de synchronisation (<a href="http://www.epsilonrt.com/avrio/group__semaphore__module.html">sémaphores</a>, 
<a href="http://www.epsilonrt.com/avrio/group__mutex__module.html">mutex</a>) 
ou de communication (tube <a href="http://www.epsilonrt.com/avrio/group__queue__module.html">FIFO</a>), 
les <a href="http://www.epsilonrt.com/avrio/group__avrio__dlist.html">listes doublement chaînées</a>,
les <a href="http://www.epsilonrt.com/avrio/group__avrio__vector.html">vecteurs</a> ...</li>
</ul>

<p>AvrIO est pré-configurée pour un grand nombre de cartes cibles industrielles 
mais peut être adapté facilement à une carte cible personnelle :</p>

<ul>
<li>fabriquées par ATMEL
<ul>
<li><a href="http://www.atmel.com/dyn/resources/prod_documents/doc1107.pdf">STK200 Starter Kit</a></li>
<li><a href="http://www.atmel.com/dyn/resources/prod_documents/doc7627.pdf">AT90USB Evaluation Kit</a></li>
<li><a href="http://www.atmel.com/dyn/resources/prod_documents/doc4271.pdf">AVR Butterfly Evaluation Kit</a></li>
<li><a href="http://www.atmel.com/dyn/resources/prod_documents/doc4381.pdf">DVK90CAN1 - AT90CAN128 Development Kit</a></li>
</ul></li>
<li>fabriquées par OLIMEX
<ul>
<li><a href="http://www.olimex.com/dev/pdf/AVR/AVR-USB-STK.pdf">AVR-USB-STK development board</a></li>
<li><a href="http://www.olimex.com/dev/pdf/AVR/AVR-CAN.pdf">AVR-CAN development board</a></li>
</ul></li>
<li>fabriquées par EGNITE
<ul>
<li><a href="http://www.ethernut.de/pdf/enhwm13e.pdf">Ethernut 1.3</a></li>
</ul></li>
</ul>

<p>Vous pouvez récupérer la toute dernière version de développement grâce à git :</p>

<pre><code>$ git clone http://github.com/epsilonrt/avrio.git
</code></pre>

<h2>Installation rapide</h2>

<pre><code>git clone http://github.com/epsilonrt/avrio.git
cd avrio
sudo make install

make set-profile
# Remove AVRIO_ROOT=... in /home/pascal/.profile
# AVRIO_ROOT=/home/pascal/src/avrio was added
#  in /home/pascal/.profile
# You must log out for this to take effect.
</code></pre>
@endhtmlonly

@defgroup avrx_module Noyau temps réel AvrX
  AvrX est un noyau temps réel multitâche développé en assembleur par Larry
  Barello. Ce noyau est utilisable en C grâce une interface API riche de
  plusieurs dizaines de fonctions. \n
  La version actuelle intégrée à AvrIO s'appuie sur la dernière version
  diffusé par Larry (2.6f). Il s'agit d'une branche qui dérive du projet
  original et qui va évoluer en parallèle (il semble que Larry aie décidé
  de ne plus faire évoluer AvrX ...). \n
  Le but de cette nouvelle version est de proposer une solution totalement
  intégrée à AvrIO, respectant ses objectifs de modularité et de légéreté,
  de séparation des parties spécifiques au matériel,
  tout en étant implantable sur tous les modèles d'AVR (ce qui n'est pas le
  cas du projet d'origine). \n
  Les autres axes de développement sont de :
  - Simplifier son API pour le rendre utilisable par un électronicien "lambda"
  - Documenter "proprement" le projet (avec
    <a href="http://www.doxygen.org">doxygen</a>), en français, pour le
    moment.
  - Faciliter sa diffusion et le travail collaboratif grâce à
    <a href="http://subversion.apache.org">subversion</a>.
  .
  Le projet original peut être consulté à l'adresse suivante
  <a href="http://www.barello.net/avrx">http://www.barello.net/avrx</a>.

@defgroup sys_group  Modules systèmes
@defgroup dev_group  Modules d'entrées/sorties
@defgroup net_group  Modules réseau
@defgroup util_group Modules utilitaires
@defgroup robotic_group Modules robotiques
@defgroup defs_group Définitions et macros
@defgroup test_group Tests des modules
@addtogroup net_group
@{
  @defgroup wusb_module Réseau WirelessUSB
  @{
    WirelessUSB&tm; est une marque déposée par Cypress Semiconductor Corporation.\n
    @warning Ce module est en version alpha et n'est pas encore fonctionnel.
    Il est préférable d'utilser le module \ref idwarf_module pour l'instant.
    Dépendances: \n
    - \ref delay_module
    - \ref spi_module
    - \ref state_module
    - \ref queue_module
    .
  @}

  @defgroup twi_group Bus I2C
  @{
    Regroupe tous les modules I2C permettant de gérer les coupleurs (TWI, USI,
    Bit Bang) et les ciruits intégrés utilisant ce bus.

    @defgroup twi_devices_group Circuits intégrés I2C
    Regroupe les ciruits intégrés utilisant le bus I2C.
  @}

  @defgroup radio_group Liaisons radio
  @{
    Regroupe tous les modules concernant les réseaux radioélectriques.
  @}

@}
*/
